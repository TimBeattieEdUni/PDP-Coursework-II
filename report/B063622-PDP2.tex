%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MSc HPC
% Parallel Design Patterns
% Coursework Part II
% Exam no. B063622
%
% Report.
%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Packages.
%
\documentclass[11pt, oneside]{article}   % use "amsart" instead of "article" for AMSLaTeX format
\usepackage{geometry}                    % See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   % ... or a4paper or a5paper or ... 
\usepackage[parfill]{parskip}            % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}                    % Use pdf, png, jpg, or epsÂ§ with pdflatex; use eps in DVI mode
                                         % TeX will automatically convert eps --> pdf in pdflatex		
\usepackage{epstopdf}
\usepackage{amssymb}
\usepackage{listings}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
language=c++,
aboveskip=3mm,
belowskip=3mm,
showstringspaces=false,
columns=flexible,
basicstyle={\small\ttfamily},
numbers=none,
numberstyle=\tiny\color{gray},
keywordstyle=\color{blue},
commentstyle=\color{dkgreen},
stringstyle=\color{mauve},
breaklines=false,
breakatwhitespace=true,   
tabsize=3
}


% load .eps files created by GnuPlot for epstopdf to convert to .pdf
\DeclareGraphicsExtensions{.eps}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Components.
\title{Parallel Design Patterns Coursework Part II}
\author{Exam no. B063622}
\date{\today}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The document itself.
%
\begin{document}

\pagenumbering{gobble}   % No page number on title page.
\maketitle

\newpage

\pagenumbering{roman}   % Preamble pages numbered in Roman numerals.
\tableofcontents

\newpage

\pagenumbering{arabic}  % Body of report numbered in Arabic.

\section{Introduction}

The following report describes the design and implementation of a parallel program which simulates a population of squirrels and the incidence of squirrel parapoxvirus in that population.
The squirrel population inhabits a landscape which is involved in the spread of the virus, and individual squirrels move within the landscape and contaminate it with the disease if infected.

The program is implemented in C++ using MPI for parallelisation and can be built on the CPLabs machines and via the SGE batch system on MORAR.
The program's source code is provided as a zipped tar archive which can be unpacked with the following command:

\begin{lstlisting}
	tar -xvzf B063622-PDP2.tar.gz
\end{lstlisting}

For instructions on how to build and run the progam, see the file \textbf{README.md} in the archive's top-level directory.

\newpage

\section{Program Design}
Squirrel stores stats from cell at time it visits, keeps 50 records.
Each actor is a class driven by calling Update().
Pool is polling, so actors are too.
PoolWorker/Master classes just instantiate an actor and kick it regularly.
Pool classes take care of calling shouldWorkerStop() and workerSleep()
Messaging approach is fire and forget.
Cells don't know or care which one they are; independent of grid arrangement so flexible when biologists change their map format.

\newpage

\section{Implementation}
The program was implemented as a set of C++ classes which fell roughly into three categories: those which handled with the process pool, those which implemented the actors, and those which handled miscellaneous tasks like reading the program's configuration options from the command line (class {\em Config}) and calculating the simulation's current day and week from wall clock times obtained from the system (class {\em DayTicker}).

The classes were organised in two namespaces: namespace {\em Mpi} and namespace {\em Biology}.
The former included all classes which dealt with the MPI-based process pool, and the latter contained classes which were specific to the squirrel simulation.
Code which was provided to the developer in C source files was used without modification.

Class Mpi::Mpi was a simple Resource Acquisition is Initialisation (RAII) \cite{ref:Stroustrup} class which initialised the MPI environment in its constructor and terminated the environment in its destructor.
This ensured that the required call to MPI\_Finalize() would take place even in the case of an exception being thrown.  

Class {\em MPI::Communicator} was a simple class which retrieved the MPI communicator size and rank of the process and made them available to user code without having to make a separate function call to write the values to a variable.  

\subsection{Actor Classes}
Classes {\em Biology::Squirrel}, {\em Biology::Cell}, and {\em Biology::Coordinator} represented the pattern's actors.
Each had a simple interface: client code could run an actor by instantiating an object of the desired type and then calling the actor's {\em Update()} function until that function returned false to indicate the actor's work was done.  
This method of driving the actors was prompted by the polling interface in the provided process pool code; the decision was made to work in the same manner as the provided code rather than mix approaches.

In between calls to {\em Update()} the client code could perform any other tasks necessary to manage the program.
In the case of class {\em PoolWorker} this work consisted of calling {\em shouldWorkerStop()} to poll the process pool to see if the pool was shutting down.

\subsection{Actor Classes}
Actor classes - driven by Update(), returns true/false for run me again/don't.
Actors should be driven until Update() returns false.
Then squirrels can be reused, but cells and coord just exit.



Header include order minimises dependencies.
Ideally a communicator for just the actors, but would've had to modify pool.
Create worker, worker waits for message telling it what type of actor to be.
Alternative would've been to pass arguments through pool, but using pool as-is.
Simple RAII classes to init and shutdown MPI, pool, etc.
Cells start at different times and are out of sync, but this considered ok.
All procs assume master=0, coord=1, next are cells, then squirrels.
So cell pid is cell index + 2.
Coordinator does all births.
Squirrels request births from coordinator.
With just 3 days stored, individual variables bumped was fine.
For 50, used array as circular buffer.
Squirrels do their first update without notifying as per the handout.
Cells track days and print popinf and inflvl each week.
Coord also tracks days and prints total squirrels.
Coord watches max time and shuts down everything.
Coord shuts down if max squirrels, but this never happens.  Tested by adding lots of births.  Squirrels requesting this makes it easy.

\subsection{Days}
Coordinator and Cell get days from wall clock.
No need for global sync, but should be no drift.
Squirrels dayless. 

\subsection{Configuration}
Number of landscape cells configurable - hard-coded in biology but main() checks for this.

\subsection{Communication}
Actor pattern not good for synch comms as no coordination.
Most receives done with MPI\_Iprobe() as could check for new messages and handle, then do other stuff.
Squirrels directly tell coordinator birth/death/infected for stats.
Stats not synched between cells - cells could count a squirrel twice, but coordinator stats good.
Coordinator is always rank 1 - this is assumed by others.
Squirrels tell cells when they step in/out/within and expect cell to reply with stats.
Stats may come in in any order, but keeping 50 expected to smooth this out to acceptable accuracy or realism.

\section{Output}
Would conclude that sim is inaccurate - squirrels don't reproduce very well.
But starting with a tiny population which are all infected probably isn't realistic.

\section{Problems}
Found that calling shutdownPool() from one process didn't cause shouldWorkerStop() to return 0 as expected.
Not clear why, may have misunderstood.
Intermittently, calling MPI\_Wtime() returned a large constant value - whenever, by whomever, on cplabs and MORAR.
Squirrels sometimes very active before cells active, so squirrels die before getting any real stats back from cells.
Tried to make cells start first, then squirrels, and squirrels die first, then cells, and run sendrecv in between for loose synchronisation between cells and squirrels, but failed.
Squirrels have less to do and there's more of them, so they can fill a big buffer with calls to MPI\_Bsend().
Had a large buffer - empirically determined to be enough.
Debugging difficult - much printout, but of course this affects timing.
Had to think and try to be correct initially rather than throw in some code and try to figure it out later.
Max squirrels caused everyone to exit, but then a squirrel could give birth and get the process a cell had run on and not get told to shut down.
Broke decoupling by explicitly making worker exit after Actor done if Actor was coord or cell. (show code)
Generally found all squirrels die in first week.  May be because they're infected and cells don't get started soon enough to feed squirrels pop influx stats that would make them reproduce.
However, an experiment with kicking the population to keep it above 40 still had squirrels fading fast a few weeks in after all cells were up and running.
MORAR - 64 cores max.
Would be good to have a sync starting point - but how without modifying pool?
Experimented with sendrecv to make 
Sendrecv tried for squirrel-cell step/stats exchange as a form of loose coupling, but couldn't get shutdown correct - squirrels left running because cells had exited.
Tried to ensure squirrels shut down before cells, but unable to target just those workers which were actually running a squirrel.

\section{Performance}
Polling technique where simple update done then shouldWorkerStop() called may consume lots of cpu.
Good decoupling of actors from pool though; once PoolWorker/Master implemented, very rarely needed to touch them and could work on actors in isolation.



\newpage
\newpage
\section{Conclusion}
This is the conclusion.

\newpage

\begin{thebibliography}{10}

\bibitem{ref:Stroustrup} B.Stroustrup [Online] Available: http://www.stroustrup.com/bs\_faq2.html\#finally. [Accessed 02-04-2015]

\end{thebibliography}

\end{document}